<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>D3 Monthly Active Bars</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  :root {
    /* Streamlit과 자연스럽게 어울리도록 투명 배경 */
    --bg: transparent;
    --axis: #c7ced6;   /* 축 색상 */
    --grid: #eef2f7;   /* 격자선 */
    --bar: #90caf9;
  }

  html, body { margin:0; padding:0; background:var(--bg); }
  body {
    font-family:-apple-system,BlinkMacSystemFont,"Apple SD Gothic Neo","Noto Sans KR",Arial,sans-serif;
    color:#fff;
  }

  .head { display:flex; justify-content:space-between; align-items:center; padding:2px 0 8px 0; }
  .head h3 { margin:0; font-size:16px; font-weight:800; color:#ffffff; } /* 제목 흰색 */
  .wrap { padding:0; }

  .axis path, .axis line { stroke:var(--axis); }
  .grid line { stroke: var(--grid); }
  .bar { fill: var(--bar); }
  .value { font-size:12px; fill:#fff; font-weight:700; }
  .tooltip {
    position:fixed; pointer-events:none; z-index:9999; opacity:0;
    background:rgba(0,0,0,0.82); color:#fff; padding:6px 8px; border-radius:6px; font-size:12px;
  }

  /* 계절 배경: 톤다운 파스텔 팔레트 */
  .season { opacity: .32; }
  .season.winter { fill: #4682B4; }   /* 겨울 - 차분한 강철블루 */
  .season.spring { fill: #FFB7C5; }   /* 봄 - 부드러운 벚꽃핑크 */
  .season.summer { fill: #00CED1; }   /* 여름 - 시원한 터쿼이즈 */
  .season.autumn { fill: #D2691E; }   /* 가을 - 따뜻한 브라운오렌지 */

  /* 범례(legend) */
  .legend text { fill:#273142; font-size:12px; }
  .legend .bg { fill: rgba(255,255,255,0.85); stroke: #d6dbe3; rx:8; ry:8; }
</style>
</head>
<body>
<div class="wrap">
  <svg id="chart" width="100%" height="420"></svg>
</div>
<div id="tooltip" class="tooltip"></div>

<script>
// __DATA_JSON__ 은 서버(app.py)에서 문자열 치환됩니다.
// 기대 형식: [{month:1..12, count:int}, ...]
const data = __DATA_JSON__.map(d => ({ month:+d.month, count:+d.count }));

// 크기/마진
const svg = d3.select("#chart");
const bbox = svg.node().getBoundingClientRect();
const W = Math.max(680, Math.min(920, bbox.width));
const H = 380;
const M = { top: 20, right: 20, bottom: 48, left: 76 };
const innerW = W - M.left - M.right;
const innerH = H - M.top - M.bottom;
svg.attr("viewBox", `0 0 ${W} ${H}`);

// 그룹
const g = svg.append("g").attr("transform", `translate(${M.left},${M.top})`);

// 스케일
let x = d3.scaleBand().domain([12,1,2,3,4,5,6,7,8,9,10,11]).range([0, innerW]).padding(0.18);

// 데이터도 월 순서에 맞게 정렬
const orderedMonths = new Set([12,1,2,3,4,5,6,7,8,9,10,11]);
const orderedData = [...orderedMonths].map(m => data.find(d => d.month===m) || {month:m, count:0});

const maxY = d3.max(orderedData, d => d.count) || 1;
const y = d3.scaleLinear().domain([0, maxY * 1.12]).nice().range([innerH, 0]);

// 적절한 y축 틱 개수(겹침 방지)
const yTicks = Math.max(3, Math.min(8, Math.floor(innerH / 60)));

const seasons = [
  { name:"winter", label:"겨울",  color:"#4682B4", months:[12,1,2] },
  { name:"spring", label:"봄",    color:"#FFB7C5", months:[3,4,5] },
  { name:"summer", label:"여름",  color:"#00CED1", months:[6,7,8] },
  { name:"autumn", label:"가을",  color:"#D2691E", months:[9,10,11] },
];

// 격자선 전용
g.append("g")
  .attr("class","grid")
  .call(
    d3.axisLeft(y)
      .ticks(yTicks)
      .tickSize(-innerW)
      .tickFormat(() => "")
  )
  .call(g => g.select(".domain").remove());

// x축
const xAxisG = g.append("g")
  .attr("transform", `translate(0,${innerH})`)
  .call(d3.axisBottom(x).tickFormat(d => d).tickPadding(6));

// y축
const yAxisG = g.append("g")
  .attr("class","y-axis")
  .call(d3.axisLeft(y).ticks(yTicks).tickFormat(d3.format(",d")).tickPadding(6));

xAxisG.selectAll("text").style("font-size","12px").attr("dy","0.8em");
yAxisG.selectAll("text").style("font-size","12px");

const seasonG = g.append("g").attr("class","seasons");
seasons.forEach(s => {
// 연속 구간의 시작과 끝을 도메인 순서대로 잡기
const startX = x(s.months[0]); // ex) 겨울은 12월의 x
const endX   = x(s.months[s.months.length - 1]) + x.bandwidth(); // 마지막 달 막대 끝

// 방어: 도메인에 없는 달이 있을 때는 건너뜀
if (startX == null || (endX - startX) <= 0) return;

seasonG.append("rect")
  .attr("class", `season ${s.name}`)
  .attr("x", startX)
  .attr("y", 0)
  .attr("width", endX - startX)
  .attr("height", innerH)
  .attr("fill", s.color)
  .attr("opacity", 0.32);
});

// ✅ 계절 범례(legend) 추가
const legendItems = [
  { key:"spring", label:"봄",   color:"#FFB7C5" },
  { key:"summer", label:"여름", color:"#00CED1" },
  { key:"autumn", label:"가을", color:"#D2691E" },
  { key:"winter", label:"겨울", color:"#4682B4" },
];

const legend = g.append("g").attr("class","legend");
const padX = 10, padY = 8, itemH = 18, sw = 12, gap = 8;
let maxTextW = 0;

// 텍스트 폭 측정
const temp = legend.append("g").attr("opacity",0);
legendItems.forEach(d => {
  const t = temp.append("text").text(d.label).attr("font-size",12);
  const w = t.node().getBBox().width;
  if (w > maxTextW) maxTextW = w;
});
temp.remove();

// 박스 크기/위치 (오른쪽 상단)
const boxW = padX*2 + sw + gap + maxTextW;
const boxH = padY*2 + itemH * legendItems.length;
const boxX = innerW - boxW;
const boxY = 8;

legend.append("rect")
  .attr("class","bg")
  .attr("x", boxX)
  .attr("y", boxY)
  .attr("width", boxW)
  .attr("height", boxH);

legendItems.forEach((d,i) => {
  const y = boxY + padY + i*itemH + 9;
  legend.append("rect")
    .attr("x", boxX + padX)
    .attr("y", y - sw/2)
    .attr("width", sw)
    .attr("height", sw)
    .attr("fill", d.color)
    .attr("opacity", 0.9);
  legend.append("text")
    .attr("x", boxX + padX + sw + gap)
    .attr("y", y)
    .attr("dominant-baseline","middle")
    .text(d.label);
});

// 레이어
const barsG = g.append("g");
const labelsG = g.append("g");

// 툴팁
const tip = d3.select("#tooltip");

// 상태 플래그
let hasDrawn = false;

// 숫자 카운트업
function tweenCount(sel, start, end, duration=800, fmt=d3.format(",d")) {
  sel.transition().duration(duration).tween("text", function(){
    const i = d3.interpolateNumber(start, end);
    return function(t){ this.textContent = fmt(Math.round(i(t))); };
  });
}

// 초기화
function resetBars() {
  barsG.selectAll("*").interrupt().remove();
  labelsG.selectAll("*").interrupt().remove();
  tip.style("opacity", 0);
  hasDrawn = false;
}

// 그리기
function drawBars(seq=true) {
  if (hasDrawn) return;

  const bar = barsG.selectAll("rect.bar").data(orderedData, d => d.month);
  const enter = bar.enter().append("rect")
      .attr("class","bar")
      .attr("x", d => x(d.month))
      .attr("width", x.bandwidth())
      .attr("y", innerH)
      .attr("height", 0)
      .on("mousemove", (ev,d) => {
        tip.style("opacity", 1)
           .style("left", (ev.clientX + 12) + "px")
           .style("top",  (ev.clientY - 12) + "px")
           .html(`<b>${d.month}월</b><br/>건수: <b>${d3.format(",d")(d.count)}</b>`);
      })
      .on("mouseleave", () => tip.style("opacity", 0));

  const dur = 900, ease = d3.easeCubicOut;
  (seq ? enter.transition().delay((_,i)=> i*100) : enter.transition())
      .duration(dur).ease(ease)
      .attr("y", d => y(d.count))
      .attr("height", d => innerH - y(d.count));

  bar.transition().duration(800)
      .attr("x", d => x(d.month))
      .attr("width", x.bandwidth())
      .attr("y", d => y(d.count))
      .attr("height", d => innerH - y(d.count));

  bar.exit().remove();

  const lbl = labelsG.selectAll("text.value").data(orderedData, d => d.month);
  const lblEnter = lbl.enter().append("text")
    .attr("class", "value")
    .attr("x", d => x(d.month) + x.bandwidth() / 2)
    .attr("y", innerH - 6)  // 아래에서 시작
    .attr("text-anchor", "middle")
    .text("0");

  (seq ? lblEnter.transition().delay((_, i) => i * 120) : lblEnter.transition())
    .duration(dur).ease(ease)
    .tween("text", function(d) {
      const i = d3.interpolateNumber(0, d.count);
      const yStart = innerH - 6;
      const yEnd = y(d.count) - 6;
      return function(t) {
        this.textContent = d3.format(",d")(Math.round(i(t)));
        this.setAttribute("y", yStart + (yEnd - yStart) * t);  // y도 함께 보간
      };
    });

  lbl.transition().duration(800)
     .attr("x", d => x(d.month) + x.bandwidth()/2)
     .attr("y", d => y(d.count) - 6)
     .tween("text", function(d){
        return function(){ this.textContent = d3.format(",d")(d.count); };
     });

  lbl.exit().remove();

  hasDrawn = true;
}

// 초기 드로우
drawBars(true);

// 뷰포트 이탈/복귀 시 초기화/재생
const panel = document.body;
const io = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    const ratio = entry.intersectionRatio;
    if (ratio === 0 && hasDrawn) resetBars();
    else if (ratio >= 0.25 && !hasDrawn) drawBars(true);
  });
}, { root: null, rootMargin: "0px", threshold: [0, 0.25] });
io.observe(panel);

let rafId = null;
function onScrollCheck() {
  if (rafId) return;
  rafId = requestAnimationFrame(() => {
    const vh = window.innerHeight;
    const rect = panel.getBoundingClientRect();
    const out = (rect.bottom <= 0) || (rect.top >= vh);
    if (out && hasDrawn) resetBars();
    rafId = null;
  });
}
window.addEventListener('scroll', onScrollCheck, { passive: true });
window.addEventListener('resize', onScrollCheck);
</script>
</body>
</html>